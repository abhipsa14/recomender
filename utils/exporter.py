"""
Data export utilities for job scraper results.
Supports CSV, JSON, and Excel formats.
"""

import csv
import json
import logging
from pathlib import Path
from typing import List, Dict, Any, Optional
from datetime import datetime

# Try to import pandas and openpyxl for Excel support
try:
    import pandas as pd
    HAS_PANDAS = True
except ImportError:
    HAS_PANDAS = False

try:
    import openpyxl
    HAS_OPENPYXL = True
except ImportError:
    HAS_OPENPYXL = False


class BaseExporter:
    """Base class for all exporters"""
    
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
    
    def _ensure_directory_exists(self, file_path: str):
        """Ensure the directory for the file exists"""
        Path(file_path).parent.mkdir(parents=True, exist_ok=True)
    
    def _add_metadata(self, data: List[Dict], metadata: Optional[Dict] = None) -> List[Dict]:
        """Add metadata to exported data"""
        if not metadata:
            metadata = {
                'export_timestamp': datetime.now().isoformat(),
                'total_jobs': len(data),
                'exporter': self.__class__.__name__
            }
        
        # Add metadata as the first row if data exists
        if data:
            metadata_row = {'_metadata': json.dumps(metadata)}
            return [metadata_row] + data
        
        return data


class CSVExporter(BaseExporter):
    """Export job data to CSV format"""
    
    def __init__(self, encoding: str = 'utf-8'):
        """
        Initialize CSV exporter.
        
        Args:
            encoding: File encoding (default: utf-8)
        """
        super().__init__()
        self.encoding = encoding
    
    def export(self, jobs: List[Dict[str, Any]], output_file: str, 
               include_metadata: bool = True) -> str:
        """
        Export jobs to CSV file.
        
        Args:
            jobs: List of job dictionaries
            output_file: Output file path
            include_metadata: Whether to include metadata
            
        Returns:
            Path to exported file
        """
        if not jobs:
            self.logger.warning("No jobs to export")
            return output_file
        
        self._ensure_directory_exists(output_file)
        
        try:
            # Get all possible fieldnames from all jobs
            fieldnames = set()
            for job in jobs:
                fieldnames.update(job.keys())
            
            # Sort fieldnames for consistent output
            fieldnames = sorted(list(fieldnames))
            
            # Ensure common fields come first
            priority_fields = ['title', 'company', 'location', 'salary', 'posted_date', 'source', 'url']
            ordered_fieldnames = []
            
            for field in priority_fields:
                if field in fieldnames:
                    ordered_fieldnames.append(field)
                    fieldnames.remove(field)
            
            # Add remaining fields
            ordered_fieldnames.extend(sorted(fieldnames))
            
            with open(output_file, 'w', newline='', encoding=self.encoding) as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=ordered_fieldnames, 
                                      extrasaction='ignore', restval='')
                
                # Write header
                writer.writeheader()
                
                # Write metadata if requested
                if include_metadata:
                    metadata = {
                        'title': f'# Exported {len(jobs)} jobs on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}',
                        'company': '# Generated by Job Scraper',
                        'location': f'# Total jobs: {len(jobs)}'
                    }
                    writer.writerow(metadata)
                
                # Write job data
                for job in jobs:
                    # Clean data for CSV export
                    cleaned_job = {}
                    for key, value in job.items():
                        if isinstance(value, (list, dict)):
                            cleaned_job[key] = json.dumps(value) if value else ''
                        elif value is None:
                            cleaned_job[key] = ''
                        else:
                            cleaned_job[key] = str(value)
                    
                    writer.writerow(cleaned_job)
            
            self.logger.info(f"Successfully exported {len(jobs)} jobs to {output_file}")
            return output_file
            
        except Exception as e:
            self.logger.error(f"Failed to export to CSV: {e}")
            raise
    
    def export_to_csv(self, jobs: List[Dict[str, Any]], output_file: str) -> str:
        """Backward compatibility method"""
        return self.export(jobs, output_file)


class JSONExporter(BaseExporter):
    """Export job data to JSON format"""
    
    def __init__(self, indent: int = 2):
        """
        Initialize JSON exporter.
        
        Args:
            indent: JSON indentation level
        """
        super().__init__()
        self.indent = indent
    
    def export(self, jobs: List[Dict[str, Any]], output_file: str, 
               include_metadata: bool = True) -> str:
        """
        Export jobs to JSON file.
        
        Args:
            jobs: List of job dictionaries
            output_file: Output file path
            include_metadata: Whether to include metadata
            
        Returns:
            Path to exported file
        """
        if not jobs:
            self.logger.warning("No jobs to export")
            jobs = []
        
        self._ensure_directory_exists(output_file)
        
        try:
            export_data = {
                'jobs': jobs,
                'summary': {
                    'total_jobs': len(jobs),
                    'export_timestamp': datetime.now().isoformat(),
                    'exporter': self.__class__.__name__
                }
            } if include_metadata else jobs
            
            with open(output_file, 'w', encoding='utf-8') as jsonfile:
                json.dump(export_data, jsonfile, indent=self.indent, 
                         ensure_ascii=False, default=str)
            
            self.logger.info(f"Successfully exported {len(jobs)} jobs to {output_file}")
            return output_file
            
        except Exception as e:
            self.logger.error(f"Failed to export to JSON: {e}")
            raise
    
    def export_to_json(self, jobs: List[Dict[str, Any]], output_file: str) -> str:
        """Backward compatibility method"""
        return self.export(jobs, output_file)


class ExcelExporter(BaseExporter):
    """Export job data to Excel format"""
    
    def __init__(self):
        """Initialize Excel exporter"""
        super().__init__()
        
        if not HAS_PANDAS:
            self.logger.warning("pandas not available - Excel export may be limited")
        if not HAS_OPENPYXL:
            self.logger.warning("openpyxl not available - Excel export may fail")
    
    def export(self, jobs: List[Dict[str, Any]], output_file: str, 
               include_metadata: bool = True) -> str:
        """
        Export jobs to Excel file.
        
        Args:
            jobs: List of job dictionaries
            output_file: Output file path
            include_metadata: Whether to include metadata
            
        Returns:
            Path to exported file
        """
        if not jobs:
            self.logger.warning("No jobs to export")
            return output_file
        
        self._ensure_directory_exists(output_file)
        
        if not HAS_PANDAS:
            # Fallback to CSV if pandas not available
            self.logger.warning("pandas not available, falling back to CSV export")
            csv_exporter = CSVExporter()
            csv_file = output_file.replace('.xlsx', '.csv')
            return csv_exporter.export(jobs, csv_file, include_metadata)
        
        try:
            # Convert jobs to DataFrame
            df = pd.DataFrame(jobs)
            
            # Clean data for Excel export
            for col in df.columns:
                # Convert lists and dicts to strings
                df[col] = df[col].apply(lambda x: json.dumps(x) if isinstance(x, (list, dict)) else x)
                # Handle None values
                df[col] = df[col].fillna('')
            
            # Reorder columns to put important ones first
            priority_columns = ['title', 'company', 'location', 'salary', 'posted_date', 'source', 'url']
            column_order = []
            
            for col in priority_columns:
                if col in df.columns:
                    column_order.append(col)
            
            # Add remaining columns
            for col in df.columns:
                if col not in column_order:
                    column_order.append(col)
            
            df = df[column_order]
            
            # Export to Excel
            with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
                # Write main data
                df.to_excel(writer, sheet_name='Jobs', index=False)
                
                # Add metadata sheet if requested
                if include_metadata:
                    metadata_df = pd.DataFrame([
                        {'Property': 'Total Jobs', 'Value': len(jobs)},
                        {'Property': 'Export Date', 'Value': datetime.now().strftime("%Y-%m-%d %H:%M:%S")},
                        {'Property': 'Exporter', 'Value': self.__class__.__name__},
                        {'Property': 'File Format', 'Value': 'Excel (.xlsx)'}
                    ])
                    metadata_df.to_excel(writer, sheet_name='Metadata', index=False)
                
                # Get workbook and worksheet for formatting
                workbook = writer.book
                worksheet = writer.sheets['Jobs']
                
                # Auto-adjust column widths
                for column in worksheet.columns:
                    max_length = 0
                    column_letter = column[0].column_letter
                    
                    for cell in column:
                        try:
                            if len(str(cell.value)) > max_length:
                                max_length = len(str(cell.value))
                        except:
                            pass
                    
                    adjusted_width = min(max_length + 2, 50)  # Cap at 50 characters
                    worksheet.column_dimensions[column_letter].width = adjusted_width
            
            self.logger.info(f"Successfully exported {len(jobs)} jobs to {output_file}")
            return output_file
            
        except Exception as e:
            self.logger.error(f"Failed to export to Excel: {e}")
            # Fallback to CSV
            self.logger.info("Falling back to CSV export")
            csv_exporter = CSVExporter()
            csv_file = output_file.replace('.xlsx', '.csv')
            return csv_exporter.export(jobs, csv_file, include_metadata)
    
    def export_to_excel(self, jobs: List[Dict[str, Any]], output_file: str) -> str:
        """Backward compatibility method"""
        return self.export(jobs, output_file)


# Convenience functions
def export_jobs_to_csv(jobs: List[Dict[str, Any]], output_file: str) -> str:
    """Export jobs to CSV file"""
    exporter = CSVExporter()
    return exporter.export(jobs, output_file)


def export_jobs_to_json(jobs: List[Dict[str, Any]], output_file: str) -> str:
    """Export jobs to JSON file"""
    exporter = JSONExporter()
    return exporter.export(jobs, output_file)


def export_jobs_to_excel(jobs: List[Dict[str, Any]], output_file: str) -> str:
    """Export jobs to Excel file"""
    exporter = ExcelExporter()
    return exporter.export(jobs, output_file)


if __name__ == "__main__":
    # Test the exporters
    import logging
    logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(name)s - %(message)s')
    
    # Sample job data for testing
    sample_jobs = [
        {
            'title': 'Senior Python Developer',
            'company': 'Google Inc',
            'location': 'San Francisco, CA',
            'posted_date': '2024-01-15',
            'source': 'LinkedIn',
            'salary': '$120,000 - $150,000',
            'url': 'https://example.com/job1',
            'description': 'Great Python role...',
            'requirements': ['Python', 'Django', 'AWS']
        },
        {
            'title': 'Data Scientist',
            'company': 'Meta',
            'location': 'Remote',
            'posted_date': '2024-01-16',
            'source': 'Indeed',
            'salary': '$130,000 - $160,000',
            'url': 'https://example.com/job2',
            'description': 'Exciting data science position...',
            'requirements': ['Python', 'Machine Learning', 'SQL']
        }
    ]
    
    print("ðŸ§ª Testing Exporters")
    print("=" * 30)
    
    # Test CSV export
    print("Testing CSV export...")
    csv_exporter = CSVExporter()
    csv_file = csv_exporter.export(sample_jobs, 'test_output/jobs.csv')
    print(f"CSV exported to: {csv_file}")
    
    # Test JSON export
    print("\nTesting JSON export...")
    json_exporter = JSONExporter()
    json_file = json_exporter.export(sample_jobs, 'test_output/jobs.json')
    print(f"JSON exported to: {json_file}")
    
    # Test Excel export
    print("\nTesting Excel export...")
    excel_exporter = ExcelExporter()
    excel_file = excel_exporter.export(sample_jobs, 'test_output/jobs.xlsx')
    print(f"Excel exported to: {excel_file}")
    
    print("\nâœ… All export tests completed!")
